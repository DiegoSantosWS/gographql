GRAPHQL LADO BACKEND
Criando GRAPHQL com golang e gqlgen

DIEGO SANTOS
Back-end at Fliper
diegosantosws1@gmail.com
@diegosantosws

* INTRODUÇÃO

Nos ultimos anos *GRAPHQL* tem se tornado bem popular entre empresas que vem adotando o uso da *especificação* em suas aplicações,
seja em sites, sistemas ou apps mobile.

* O QUE É GRAPHQL?

GRAPHQL é uma linguagem de consultas para suas API's. Sendo também um runtime para atender a consultas com seus dados.
O serviço GRAPHQL é independente do meio de transporte, sendo usado na maioria das vezes sob o protocolo HTTP.

A especificação surgiu por volta de 2012, quando facebook teve a necessidade de reconstruir seus aplicativos moveis,
visto que na época era apenas uma view do site movel.

* DEFINIÇÃO

GRAPHQL não passa de especificação (spec) que descreve recursos e caracteristicasde para comunicação cliente/servidor

* TYPES

1 - ROOT TYPES

- QUERY
- MUTATION
- SUBSCRIPTION
- INPUT 

* 

No *GRAPHQL* existem alguns types (tipos), são conhecidos como *root* *type* (tipos raiz) que são pré definidos.

* 

2 - TYPES ESCALARES 

- Time
- Int*
- Float*
- String*
- Boolean*
- ID*

Alguns tipos escalares vem embutidos no graphql, são os marcados com * e são bem úteis, mas pode ter situções em que você precisará personalizar seus proprios tipos.

OBS: Esses tipos não é considerado um objeto pois não tem campos

Um exemplo é o tipo *Time* usaso no campo *Created* do schema *Person*

* EXEMPLO DE SCHEMAS PARA TIPOS ESCALARES.

.code codes/example.graphql

* QUERYS

É definido como root type. Os campos distponives na query para consultas são definidos no SCHEMA.

OBS: Uma query serve realizar consultas. É o mesmo que fazer uma requisição usando o verbo GET. 

"NA VERDADE ESTAMOS USANDO ELE NO *RESOLVER* NA MAIORIA DAS CONSULTAS"


* EXEMPLO DE SCHEMA PARA CHAMADAS DAS QUERY E MUTATION

.code codes/definicaoquery.graphql

Quando começamos a usar GRAPHQL precisamos instalar um cliente para testarmos querys e motations, esse cliente contem
um playground. onde vamos executar as chamadas, um exemplo online é: 
.link https://swapi.graph.cool/ swapi

* EXEMPLO DE USABILIDADE PARA QUERY

.code codes/exemplos.json

* MUTATION

As Mutações também são definidas em um SCHEMA assim como as querys, possuem seus tipos objetos personalizados, que devem ser adicionados no schema. Não existe muita diferença
no modo de definir uma mutação ou query.

A diferença existente esta na interação. Forma de usar uma *MUTATION* é quando houver uma ação, evento de mudar algo que diz respeito ao estado de um registro.

Uma *MUTATION* deve representar os verbos HTTP em sua aplicação.

* EXEMPLO

.code codes/mutations.graphql

* TYPE INPUT

Este tipo costuma ser usado quando tempos muitos parametros a ser passado para uma mutation. O INPUT é uma forma de organizar.
O INPUT é semelhante a um objeto GRAPHQL exeto pq é usado somente como argumento de entrada, para mutation.

* RESOLVERS

Resolver é uma função que devolve dados para um campo  em particular. Resolvers devolvem dados no tipo e formato especificados pelo schema.

* 
Para exemplificar um resolver vamos uar uma lib e falar um pouco de golang que o objetivo.

* GQLGEN

GQLGEN é uma lib feita interamente em go ajudar na criação do graphql. GQLGEN é um mistério a ser desvendado.
A lib trabalha com contexto o tempo inteiro.

Quando escolhi usa-la levei em consideração o fato dela ajudar na criação de todo processo. Como assim?

Em outras lib's como go-graphql temos que criar tudo, então podemos ganhar um pouco de performance e autonomia do código.
pore a nivel de praticidade perdemos muito. Visto que na época eu precisava de praticidade deixei um pouco da performance para refatoração.

* INICIANDO GQLGEN

Para iniciar gqlgen usamos os comandos referente a qualquer lib

go get github.com/99designs/gqlgen

EXEMPLO DO SITE
``
$ mkdir gqlgen-todos
$ cd gqlgen-todos
$ go mod init github.com/[username]/gqlgen-todos
``

Assim conseguimos inicar um projeto.

Após o procedimento acima GQLGEN cria alguns arquivos / diretorio. Sendo eles.

* 
- gqlgen.yml 
O yml é o arquivo de configuração do codigo, neste arquivos que definimos a estrutura que devemos uasar. (caso não definirmos ele vai criar uma confome o schema definido)

- generated.go
Este arquivo contem a maior parte processo de execução do sistema.

- models_gen.go
Caso o gql gere o codigo vai está neste arquivo (Se mudar algo aqui vai dar pau).

- resolver.go

Neste arquivo vai conter as funções de query e mutations e o *generated* vai entrar em contato com esse arquivo para obter os
dados solicitados.

* 
- server/server.go

Onde existe a configuração do nosso servidor.

* 

Agora sim podemos pensar em resolvers, mas para isso precisamos manipular o arquivo criado, pois sempre que criarmos uma nova query ou mutation
devemos rodar o comando 

 go run github.com/99designs/gqlgen/ 

pois é ele exclue models_gen e resolver e cria tudo novamente. A melhor forma é criar 2 novos arquivos e add o resolve no .gitgnore. 

Exemplo: 

No exempre criei diretorio manager com os arquivos generated e resolver 


* 

.code codes/r.go

* 

Para exemplificar melhor vou mostrar o codigo como fica uma query e uma putation gerada via gqlgen.



.link https://github.com/graphql-go/graphql go-graphql

* Erros gqlgen

.play codes/erros.go

* EMPRESAS QUE USAM

* LINKS

.link https://swapi.co API EXEMPLO
.link https://gqlgen.com SITE GQLGEN
.link https://github.com/gobelohorizonte GITHUB GO-BH 
.link https://t.me/go_br GO BR
.link https://github.com/DiegoSantosWS MEU GITHUB
.link https://t.me/go_bh GRUPO TELEGRAM

* PERGUNTAS 

.image images/questions.gif _ 900

